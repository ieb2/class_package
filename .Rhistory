library(tidyverse)
mtcars %>% mutate_all(., as.factor)
mtcars %>% mutate_all(., as.factor) %>%
normality_correlation(., "kendall")
normality_correlation <- function(data, method){
numeric_subset <- data[sapply(data, is.numeric)]
numeric_subset_names <- colnames(numeric_subset)
if(length(numeric_subset_names) == 0){stop("The dataframe contains no numeric variables. Check variable types using `typeof()`")}
length_numeric_colnames <- length(numeric_subset_names)
qq_plots_list <- purrr::map(seq_len(length_numeric_colnames),
~one_qq_plot(numeric_subset, numeric_subset_names[[.x]]))
# In order to determine ideal qq plot layout
cols <- round(sqrt(length(qq_plots_list)),0)
rows <- ceiling(length(qq_plots_list)/cols)
qq_plots_out <-
ggpubr::ggarrange(plotlist = qq_plots_list, ncol = cols, nrow = rows)
corr_mat <- cor(numeric_subset, method = method)
normality_res <- lapply(numeric_subset, shapiro.test) %>%
do.call(rbind, .) %>%
data.frame() %>%
tibble::rownames_to_column("Variable") %>%
dplyr::select(-c(method, `data.name`)) %>%
dplyr::rename("Test Statistic" = "statistic", "p-value" = "p.value")
out_list <- list("Normality Test" = normality_res,
"Correlation Matrix" = corr_mat,
"QQ Plots" = qq_plots_out)
return(out_list)
}
normality_correlation <- function(data, method){
if(!(method %in% c("pearson", "kendall", "spearman"))){stop("The method specified is not one supported by the `cor()` function.")}
numeric_subset <- data[sapply(data, is.numeric)]
numeric_subset_names <- colnames(numeric_subset)
if(length(numeric_subset_names) == 0){stop("The dataframe contains no numeric variables. Check variable types using `typeof()`")}
length_numeric_colnames <- length(numeric_subset_names)
qq_plots_list <- purrr::map(seq_len(length_numeric_colnames),
~one_qq_plot(numeric_subset, numeric_subset_names[[.x]]))
# In order to determine ideal qq plot layout
cols <- round(sqrt(length(qq_plots_list)),0)
rows <- ceiling(length(qq_plots_list)/cols)
qq_plots_out <-
ggpubr::ggarrange(plotlist = qq_plots_list, ncol = cols, nrow = rows)
corr_mat <- cor(numeric_subset, method = method)
normality_res <- lapply(numeric_subset, shapiro.test) %>%
do.call(rbind, .) %>%
data.frame() %>%
tibble::rownames_to_column("Variable") %>%
dplyr::select(-c(method, `data.name`)) %>%
dplyr::rename("Test Statistic" = "statistic", "p-value" = "p.value")
out_list <- list("Normality Test" = normality_res,
"Correlation Matrix" = corr_mat,
"QQ Plots" = qq_plots_out)
return(out_list)
}
normality_correlation(mtcars, "crazy")
normality_correlation(mtcars)
roxygen2::roxygenise()
library(rmarkdown)
usethis::use_vignette("classpackage")
library(classpackage)
data <- palmerpenguins::penguins %>%
tidyr::drop_na()
data
# For demonstration sake, we will use Kendall rank correlation
normality_and_correlation(data = data, method = "kendall")
library(classpackage)
# For demonstration sake, we will use Kendall rank correlation
normality_and_correlation(data = data, method = "kendall")
library(classpackage)
load_all(classpackage)
library(classpackage)
library(classpackage)
library(classpackage)
# For demonstration sake, we will use Kendall rank correlation
normality_and_correlation(data = data, method = "kendall")
library(classpackage)
devtools::load_all(".")
library(classpackage)
library(classpackage)
classpackage::one_qq()
library(classpackage)
library(classpackage)
# For demonstration sake, we will use Kendall rank correlation
normality_correlation(data, "kendall")
library(classpackage)
devtools::check()
devtools::check_rhub(env_vars=c(R_COMPILE_AND_INSTALL_PACKAGES = "always"))
devtools::document()
devtools::check_rhub(env_vars=c(R_COMPILE_AND_INSTALL_PACKAGES = "always"))
devtools::install(build_vignette = FALSE)
devtools::load_all(classpackage)
devtools::load_all("classpackage")
devtools::load_all(DESCRIPTION)
devtools::load_all("DESCRIPTION")
devtools::load_all("/Users/ihsanbuker/classpackage")
library(classpackage)
devtools::load_all("/Users/ihsanbuker/classpackage")
devtools::load_all("/Users/ihsanbuker/classpackage")
library(classpackage)
devtools::load_all("/Users/ihsanbuker/classpackage")
library(classpackage)
classpackage::normality
# For demonstration sake, we will use Kendall rank correlation
normality_correlation(data, "kendall")
# For demonstration sake, we will use Kendall rank correlation
output <- normality_correlation(data, "kendall")
output[["QQ Plots"]]
output[["Normality Test"]]
output[["Normality Test"]] %>% unnest()
devtools::load_all("/Users/ihsanbuker/classpackage")
# devtools::load_all("/Users/ihsanbuker/classpackage")
library(classpackage)
library(tidyverse)
# For demonstration sake, we will use Kendall rank correlation
output <- normality_correlation(data, "kendall")
output
devtools::load_all("/Users/ihsanbuker/classpackage")
library(classpackage)
# For demonstration sake, we will use Kendall rank correlation
output <- normality_correlation(data, "kendall")
output
normality_correlation <- function(data, method, digits_desired = NULL){
if(is.null(digits_desired)){digits_desired <- 5}
else{digits_desired <- digits_desired}
if(!(method %in% c("pearson", "kendall", "spearman"))){stop("The method specified is not one supported by the `cor()` function.")}
numeric_subset <- data[sapply(data, is.numeric)]
numeric_subset_names <- colnames(numeric_subset)
if(length(numeric_subset_names) == 0){stop("The dataframe contains no numeric variables. Check variable types using `typeof()`")}
length_numeric_colnames <- length(numeric_subset_names)
qq_plots_list <- purrr::map(seq_len(length_numeric_colnames),
~one_qq_plot(numeric_subset, numeric_subset_names[[.x]]))
# In order to determine ideal qq plot layout
cols <- round(sqrt(length(qq_plots_list)),0)
rows <- ceiling(length(qq_plots_list)/cols)
qq_plots_out <-
ggpubr::ggarrange(plotlist = qq_plots_list, ncol = cols, nrow = rows)
corr_mat <- cor(numeric_subset, method = method)
normality_res <- lapply(numeric_subset, shapiro.test) %>%
do.call(rbind, .) %>%
data.frame() %>%
tibble::rownames_to_column("Variable") %>%
dplyr::select(-c(method, `data.name`)) %>%
dplyr::rename("Test Statistic" = "statistic", "p-value" = "p.value") %>%
tidyr::unnest()
out_list <- list("Normality Test" = normality_res,
"Correlation Matrix" = corr_mat,
"QQ Plots" = qq_plots_out)
return(out_list)
}
normality_correlation(mtcars, "kendall")
normality_correlation <- function(data, method, digits_desired = NULL){
if(is.null(digits_desired)){digits_desired <- 5}
else{digits_desired <- digits_desired}
if(!(method %in% c("pearson", "kendall", "spearman"))){stop("The method specified is not one supported by the `cor()` function.")}
numeric_subset <- data[sapply(data, is.numeric)]
numeric_subset_names <- colnames(numeric_subset)
if(length(numeric_subset_names) == 0){stop("The dataframe contains no numeric variables. Check variable types using `typeof()`")}
length_numeric_colnames <- length(numeric_subset_names)
qq_plots_list <- purrr::map(seq_len(length_numeric_colnames),
~one_qq_plot(numeric_subset, numeric_subset_names[[.x]]))
# In order to determine ideal qq plot layout
cols <- round(sqrt(length(qq_plots_list)),0)
rows <- ceiling(length(qq_plots_list)/cols)
qq_plots_out <-
ggpubr::ggarrange(plotlist = qq_plots_list, ncol = cols, nrow = rows)
corr_mat <- cor(numeric_subset, method = method)
normality_res <- lapply(numeric_subset, shapiro.test) %>%
do.call(rbind, .) %>%
data.frame() %>%
tibble::rownames_to_column("Variable") %>%
dplyr::select(-c(method, `data.name`)) %>%
dplyr::rename("Test Statistic" = "statistic", "p-value" = "p.value") %>%
tidyr::unnest(cols = c(`Test Statistic`, `p-value`))
out_list <- list("Normality Test" = normality_res,
"Correlation Matrix" = corr_mat,
"QQ Plots" = qq_plots_out)
return(out_list)
}
normality_correlation(mtcars, "kendall")
normality_correlation(mtcars, "kendall", desired_digits = 0)
normality_correlation(mtcars, "kendall", digits_desired = 0)
normality_correlation <- function(data, method, digits_desired = NULL){
if(is.null(digits_desired)){digits_desired <- 5}
else{digits_desired <- digits_desired}
if(!(method %in% c("pearson", "kendall", "spearman"))){stop("The method specified is not one supported by the `cor()` function.")}
numeric_subset <- data[sapply(data, is.numeric)]
numeric_subset_names <- colnames(numeric_subset)
if(length(numeric_subset_names) == 0){stop("The dataframe contains no numeric variables. Check variable types using `typeof()`")}
length_numeric_colnames <- length(numeric_subset_names)
qq_plots_list <- purrr::map(seq_len(length_numeric_colnames),
~one_qq_plot(numeric_subset, numeric_subset_names[[.x]]))
# In order to determine ideal qq plot layout
cols <- round(sqrt(length(qq_plots_list)),0)
rows <- ceiling(length(qq_plots_list)/cols)
qq_plots_out <-
ggpubr::ggarrange(plotlist = qq_plots_list, ncol = cols, nrow = rows)
corr_mat <- cor(numeric_subset, method = method) %>%
round(., digits = digits_desired)
normality_res <- lapply(numeric_subset, shapiro.test) %>%
do.call(rbind, .) %>%
data.frame() %>%
tibble::rownames_to_column("Variable") %>%
dplyr::select(-c(method, `data.name`)) %>%
dplyr::rename("Test Statistic" = "statistic", "p-value" = "p.value") %>%
tidyr::unnest(cols = c(`Test Statistic`, `p-value`)) %>%
mutate_if(is.numeric, ~round(digits = digits_desired))
out_list <- list("Normality Test" = normality_res,
"Correlation Matrix" = corr_mat,
"QQ Plots" = qq_plots_out)
return(out_list)
}
normality_correlation(mtcars, "kendall", digits_desired = 0)
normality_correlation <- function(data, method, digits_desired = NULL){
if(is.null(digits_desired)){digits_desired <- 5}
else{digits_desired <- digits_desired}
if(!(method %in% c("pearson", "kendall", "spearman"))){stop("The method specified is not one supported by the `cor()` function.")}
numeric_subset <- data[sapply(data, is.numeric)]
numeric_subset_names <- colnames(numeric_subset)
if(length(numeric_subset_names) == 0){stop("The dataframe contains no numeric variables. Check variable types using `typeof()`")}
length_numeric_colnames <- length(numeric_subset_names)
qq_plots_list <- purrr::map(seq_len(length_numeric_colnames),
~one_qq_plot(numeric_subset, numeric_subset_names[[.x]]))
# In order to determine ideal qq plot layout
cols <- round(sqrt(length(qq_plots_list)),0)
rows <- ceiling(length(qq_plots_list)/cols)
qq_plots_out <-
ggpubr::ggarrange(plotlist = qq_plots_list, ncol = cols, nrow = rows)
corr_mat <- cor(numeric_subset, method = method) %>%
round(., digits = digits_desired)
normality_res <- lapply(numeric_subset, shapiro.test) %>%
do.call(rbind, .) %>%
data.frame() %>%
tibble::rownames_to_column("Variable") %>%
dplyr::select(-c(method, `data.name`)) %>%
dplyr::rename("Test Statistic" = "statistic", "p-value" = "p.value") %>%
tidyr::unnest(cols = c(`Test Statistic`, `p-value`)) %>%
mutate_if(is.numeric, ~round(.x, digits = digits_desired))
out_list <- list("Normality Test" = normality_res,
"Correlation Matrix" = corr_mat,
"QQ Plots" = qq_plots_out)
return(out_list)
}
normality_correlation(mtcars, "kendall", digits_desired = 0)
normality_correlation(mtcars, "kendall")
normality_correlation <- function(data, method, digits_desired = NULL){
if(is.null(digits_desired)){digits_desired <- 5}
else{digits_desired <- digits_desired}
if(!(method %in% c("pearson", "kendall", "spearman"))){stop("The method specified is not one supported by the `cor()` function.")}
numeric_subset <- data[sapply(data, is.numeric)]
numeric_subset_names <- colnames(numeric_subset)
if(length(numeric_subset_names) == 0){stop("The dataframe contains no numeric variables. Check variable types using `typeof()`")}
length_numeric_colnames <- length(numeric_subset_names)
qq_plots_list <- purrr::map(seq_len(length_numeric_colnames),
~one_qq_plot(numeric_subset, numeric_subset_names[[.x]]))
# In order to determine ideal qq plot layout
cols <- round(sqrt(length(qq_plots_list)),0)
rows <- ceiling(length(qq_plots_list)/cols)
qq_plots_out <-
ggpubr::ggarrange(plotlist = qq_plots_list, ncol = cols, nrow = rows)
corr_mat <- cor(numeric_subset, method = method) %>%
round(., digits = digits_desired)
normality_res <- lapply(numeric_subset, shapiro.test) %>%
do.call(rbind, .) %>%
data.frame() %>%
tibble::rownames_to_column("Variable") %>%
dplyr::select(-c(method, `data.name`)) %>%
dplyr::rename("Test Statistic" = "statistic", "p-value" = "p.value") %>%
tidyr::unnest(cols = c(`Test Statistic`, `p-value`)) %>%
mutate_if(is.numeric, ~round(.x, digits = digits_desired))
out_list <- list("Normality Test" = normality_res,
"Correlation Matrix" = corr_mat,
"QQ Plots" = qq_plots_out)
return(out_list)
}
normality_correlation(mtcars, "kendall")
normality_correlation(mtcars, "kendall", digits_desired = 100)
roxygen2::roxygenise(clean = TRUE)
output
# For demonstration sake, we will use Kendall rank correlation
output <- normality_correlation(data, "kendall")
output
# For demonstration sake, we will use Kendall rank correlation
output <- normality_correlation(data, "kendall", digits_desired = 10)
output
print(output)
names(output)
correlation_matrix <- output[["Correlation Matrix"]]
correlation_matrix
correlation_matrix
one_qq_plot(data, "bill_length_mm")
independent_qq_plot(data, variable = "bill_length_mm", "sex")
independent_qq_plot(wide_dataset, variable = "arbitrary measurement",
grouping_variable = "arbitrary separator",
c("group_1", "group_2"))
wide_dataset <- data.frame(group_1 = rnorm(500, 0,1),
group_2 = rnorm(500, 1, 1))
independent_qq_plot(wide_dataset, variable = "arbitrary measurement",
grouping_variable = "arbitrary separator",
c("group_1", "group_2"))
long_dataset <- data.frame(measurements = c(rnorm(500, 0,1),
rnorm(500, 1, 1)),
which_measurement = rep(c("first", "second"), each = 500))
long_dataset
styler:::style_selection()
styler:::style_active_file()
dependent_qq_plot(long_dataset, variable = "measurements",
grouping_variable = "which_measurement",
first_group = "first",
second_group = "second")
wide_dataset
dependent_qq_plot(wide_dataset, variable = "arbitrary measurement",
grouping_variable = "arbitrary separator",
first_group = "group_1",
second_group = "group_2")
wide_dataset
dependent_qq_plot(wide_dataset, variable = "arbitrary measurement",
grouping_variable = "arbitrary separator",
first_group = "group_1",
second_group = "group_2")
devtools::load_all("/Users/ihsanbuker/classpackage")
library(classpackage)
library(tidyverse)
dependent_qq_plot(wide_dataset, variable = "arbitrary measurement",
grouping_variable = "arbitrary separator",
first_group = "group_1",
second_group = "group_2")
wide_dataset
dependent_qq_plot(wide_dataset, variable = "measurements",
grouping_variable = "which_measurement",
first_group = "group_1",
second_group = "group_2")
library(classpackage)
devtools::load_all("/Users/ihsanbuker/classpackage")
library(classpackage)
library(tidyverse)
usethis::use_package(c("ggplot2", "ggpubr", "magrittr", "purrr"))
roxygen2::roxygenise(clean = TRUE)
roxygen2::roxygenise(clean = TRUE)
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise(clean = TRUE)
library(classpackage)
library(classpackage)
devtools::load_all("/Users/ihsanbuker/classpackage")
library(classpackage)
library(tidyverse)
dependent_qq_plot(wide_dataset, variable = "measurements",
grouping_variable = "which_measurement",
first_group = "first_measurement",
second_group = "second_measurement")
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
options(tidyverse.quiet = TRUE)
devtools::load_all("/Users/ihsanbuker/classpackage")
library(classpackage)
library(tidyverse)
data <- palmerpenguins::penguins %>%
tidyr::drop_na()
# For demonstration sake, we will use Kendall rank correlation
output <- normality_correlation(data, "kendall")
names(output)
correlation_matrix <- output[["Correlation Matrix"]]
correlation_matrix
one_qq_plot(data, "bill_length_mm")
independent_qq_plot(data,
variable = "bill_length_mm",
grouping_variable = "sex"
)
wide_dataset <- data.frame(
group_1 = rnorm(500, 0, 1),
group_2 = rnorm(500, 1, 1)
)
independent_qq_plot(wide_dataset,
variable = "arbitrary measurement",
grouping_variable = "arbitrary separator",
c("group_1", "group_2")
)
wide_dataset <- data.frame(
first_measurement = rnorm(500, 0, 1),
second_measurement = rnorm(500, 1, 1)
)
long_dataset <- data.frame(
measurements = c(
rnorm(500, 0, 1),
rnorm(500, 1, 1)
),
which_measurement = rep(c("first", "second"), each = 500)
)
dependent_qq_plot(wide_dataset, variable = "measurements",
grouping_variable = "which_measurement",
first_group = "first_measurement",
second_group = "second_measurement")
dependent_qq_plot(long_dataset, variable = "measurements",
grouping_variable = "which_measurement",
first_group = "first",
second_group = "second")
dependent_qq_plot(wide_dataset, variable = "measurements",
grouping_variable = "which_measurement",
first_group = "first_measurement",
second_group = "second_measurement")
unlink("vignettes/classpackage_cache", recursive = TRUE)
wide_dataset
roxygen2::roxygenise(clean=TRUE)
styler:::style_selection()
styler:::style_selection()
styler:::style_selection()
library(classpackage)
unloadNamespace()
lapply(paste('package:',names(sessionInfo()$otherPkgs),sep=""),detach,character.only=TRUE,unload=TRUE)
detachAllPackages <- function() {
basic.packages <- c("package:stats","package:graphics","package:grDevices","package:utils","package:datasets","package:methods","package:base")
package.list <- search()[ifelse(unlist(gregexpr("package:",search()))==1,TRUE,FALSE)]
package.list <- setdiff(package.list,basic.packages)
if (length(package.list)>0)  for (package in package.list) detach(package, character.only=TRUE)
}
detachAllPackages()
library(classpackage)
roxygen2::roxygenise(clean = TRUE)
library(ggplot2)
remove.packages("ggplot2")
roxygen2::roxygenise(clean = TRUE)
library(classpackage)
roxygen2::roxygenise(clean = TRUE)
my_ans <- function(n){factorial(n)^2 / factorial(2n-1)}
my_ans <- function(n) {factorial(n)^2 / factorial(2n-1)}
my_ans <- function(n) {factorial(n)^2 / factorial(2n-1)}
my_ans <- function(n) {
factorial(n)^2 / factorial(2n-1)
{factorial(n)^2} / factorial(2n-1)
{factorial(n)^2} / {factorial(2n-1)}
{factorial(n)^2} \ {factorial(2n-1)}
{factorial(n)^2}  {factorial(2n-1)}
my_ans <- function(n) {
num<- {factorial(n)^2}
den <- {factorial(2n-1)}
function(n){
print(n)
}
factorial(n)/factorial(n-1)
my_ans <- function(n) {
factorial(n)/factorial(n-1)
}
{factorial(n)}/factorial(n-1)
my_ans <- function(n) {
{factorial(n)}/factorial(n-1)
}
my_ans <- function(n) {
{factorial(n)^2}/factorial(n-1)
}
my_ans <- function(n) {
{factorial(n)^2}/factorial(2n-1)
my_ans <- function(n) {
{factorial(n)^2}/factorial({{2*n}-1})
}
my_ans(10)
my_ans(100)
my_ans(10)
my_ans(11)
my_ans(2)
my_ans(3)
choose(n, 2) * factorial(n) * n^n^{-1}
right_ans <- function(n) {
choose(n, 2) * factorial(n) * n^n^{-1}
}
right_ans(10)
right_ans(10)
right_ans <- function(n) {
choose(n, 2) * factorial(n) * {n^n^{-1}}
}
right_ans(10)
{choose(n, 2) * factorial(n)} / {n^n}
right_ans <- function(n) {
{choose(n, 2) * factorial(n)} / {n^n}
}
right_ans(10)
my_ans(10)
my_vec <- my_ans(seq(0,10, 1))
my_vec <- my_ans(seq(1,10, 1))
my_vec
my_vec <- my_ans(seq(1,11, 1))
my_vec
my_vec <- my_ans(seq(1,15, 1))
my_vec
my_vec <- my_ans(seq(1,19, 1))
my_vec
my_vec <- my_ans(seq(1,20, 1))
my_vec
my_vec <- my_ans(seq(1,30, 1))
my_vec
right_vec <- right_ans(seq(1,30, 1))
right_vec
my_vec
cbind(my_vec, right_vec)
cbind(my_vec, right_vec) %>% as.data.frame()
library(tidyverse)
cbind(my_vec, right_vec) %>% as.data.frame()
cbind(my_vec, right_vec) %>% as.data.frame() %>%
plot()
right_vec <- right_ans(seq(1,300, 1))
my_vec <- my_ans(seq(1,300, 1))
right_vec <- right_ans(seq(1,300, 1))
cbind(my_vec, right_vec) %>% as.data.frame() %>%
plot()
right_vec
my_vec
my_vec <- my_ans(seq(1,90, 1))
right_vec <- right_ans(seq(1,90, 1))
cbind(my_vec, right_vec) %>% as.data.frame() %>%
plot()
